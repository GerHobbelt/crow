
#pragma once

#include <string>
#include <unordered_map>
#include <boost/algorithm/string.hpp>
#include <algorithm>

#include "cc/llhttp.h"
#include "cc/http_request.h"

namespace cc { template <typename Handler> struct HTTPParser : public http_parser { static int on_message_begin(http_parser* self_) { HTTPParser* self = static_cast<HTTPParser*>(self_); self->clear(); return 0; } static int on_url(http_parser* self_, const char* at, size_t length) { HTTPParser* self = static_cast<HTTPParser*>(self_); self->raw_url.insert(self->raw_url.end(), at, at + length); return 0; } static int on_header_field(http_parser* self_, const char* at, size_t length) { HTTPParser* self = static_cast<HTTPParser*>(self_); switch (self->header_building_state) { case 0: if (!self->header_value.empty()) { self->headers.emplace(std::move(self->header_field), std::move(self->header_value)); } self->header_field.assign(at, at + length); self->header_building_state = 1; break; case 1: self->header_field.insert(self->header_field.end(), at, at + length); break; } return 0; } static int on_header_value(http_parser* self_, const char* at, size_t length) { HTTPParser* self = static_cast<HTTPParser*>(self_); switch (self->header_building_state) { case 0: self->header_value.insert(self->header_value.end(), at, at + length); break; case 1: self->header_building_state = 0; self->header_value.assign(at, at + length); break; } return 0; } static int on_headers_complete(http_parser* self_) { HTTPParser* self = static_cast<HTTPParser*>(self_); if (!self->header_field.empty()) { self->headers.emplace(std::move(self->header_field), std::move(self->header_value)); } self->set_connection_parameters(); self->process_header(); return 0; } static int on_body(http_parser* self_, const char* at, size_t length) { HTTPParser* self = static_cast<HTTPParser*>(self_); self->body.insert(self->body.end(), at, at + length); return 0; } static int on_message_complete(http_parser* self_) { HTTPParser* self = static_cast<HTTPParser*>(self_);  self->url = self->raw_url.substr(0, self->raw_url.find('?')); self->url_params = query_string(self->raw_url); self->process_message(); return 0; } HTTPParser(Handler* handler) : handler_(handler) { llhttp_init(this, HTTP_REQUEST, &settings_); }  bool feed(const char* buffer, int length) { return llhttp_execute(this, buffer, length) == 0; } void clear() { url.clear(); raw_url.clear(); header_field.clear(); header_value.clear(); headers.clear(); url_params.clear(); body.clear(); header_building_state = 0; http_major = 0; http_minor = 0; } void process_header() { handler_->handle_header(); } void process_message() { handler_->handle(); } inline void set_connection_parameters() {   keep_alive = (http_major == 1 && http_minor == 0) ? ((flags & F_CONNECTION_KEEP_ALIVE) ? true : false) : ((http_major == 1 && http_minor == 1) ? true : false);  close_connection = (http_major == 1 && http_minor == 0) ? ((flags & F_CONNECTION_KEEP_ALIVE) ? false : true) : ((http_major == 1 && http_minor == 1) ? ((flags & F_CONNECTION_CLOSE) ? true : false) : false); } Req to_request() const { return Req{ static_cast<HTTP>(method), std::move(raw_url), std::move(url), std::move(url_params), std::move(headers), std::move(body), keep_alive, close_connection, static_cast<bool>(upgrade) }; } inline bool check_version(unsigned char major, unsigned char minor) const { return http_major == major && http_minor == minor; } std::string raw_url; std::string url; int header_building_state = 0; std::string header_field; std::string header_value; ci_map headers; query_string url_params; std::string body; bool keep_alive;   bool close_connection;  Handler* handler_; constexpr static http_parser_settings settings_ = { on_message_begin, on_url, nullptr, on_header_field, on_header_value, on_headers_complete, on_body, on_message_complete, }; };}